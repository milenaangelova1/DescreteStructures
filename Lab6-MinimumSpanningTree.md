
# Оптимални алгоритми за намиране на минимално покриващо дърво


## Алгоритъм на Крускал
```
    Разглеждаме претеглен неориентиран граф G(V, E).  
    Алгоритъм на Крускал за намиране на минимално покриващо дърво. 
    1) Създаваме n множества, като в i-тото множество поставяме i-тия връх от графа. 
    2) Сортираме ребрата на графа във възходящ ред (по теглата им). 
    3) Създаваме празно дърво T(V,{}). След приключване на алгоритъма T ще бъде търсеното покриващо дърво.  
    4) Последователно (n–1 пъти) добавяме ребро (i,j)ϵЕ към T, така че да бъде изпълнено: 
        - теглото f(i, j) да бъде възможно най-малко (разполагаме със сортиран по теглата списък на ребрата от графа) 
        - върховете i и j да се намират в различни множества 
        След всяко добавено ребро (i,j) обединяваме множествата, в които се намират i и j.  
```
<pre>
    <code>
    #define NO_PARENT (unsigned)(-1)

    /* Максимален брой върхове в графа */
    ...
    /* Максимален брой ребра в графа */
    ...
    /* Брой върхове в графа */ 
    ...
    /* Брой ребра в графа */ 
    ...

    /*структура представяща реброто на графа.*/
    struct arc {
        ...
    };

    /* Списък от ребрата на графа и техните тегла */
    struct arc S[MAXN] = {  
        ...
    };

    /* масив съдържащ всички посетени върхове*/
    int prev[MAXN + 1];

    /* намиране на корена на дървото */
    int getRoot(int i)
    { 
        int root, save_i;
        /* намиране на корена на дървото */
        root = i;
        while (NO_PARENT != prev[root]) {
            root = prev[root]; /* свиване на пътя */
        }
        while (i != root) {
            save_i = i;
            i = prev[i];
            prev[save_i] = root;
        }
        return root;
    }

    void kruskal(void) { 
        /* MST ще пази стойността на минималният път.*/
        int MST = 0;

        /* сортира списъка с ребрата в нарастващ ред по тяхното тегло 
        където S е списъкът със ребрата на графа, 
                0 - започва от първият връх
                m - последният връх, т.е. общият брой върхове.
        */ 
        sort(S, 0, m);
        printf("Ребрата, които участват в минималното покриващо дърво:\n"); 
        for (i = 0; i < m; i++) {
            /*намираме корена на i-ят и j-ят връх
            int root1 = ...
            int root2 = ...
            /*
                Ако корените са различни, ги принтираме на екрана и 
                увеличаваме стойността на MST. Добавяме root2 към 
                масива на посетените върхове.
            */
            ...
        }
        printf("\nЦената на минималното покриващо дърво е %d.\n", MST); 
    }
    
    
    int main() {
    unsigned i;
        
        /*
            Създаваме n множества, като в i-тото множество поставяме i-тия връх от графа. 
        */
        kruskal();
        return 0;
    }
    </code>
</pre>

## Алгоритъм на Прим
```
Алтернатива нa алгоритъма на Крускал за намиране на минимално покриващо дърво е алгоритъмът на Прим.  
Алгоритъм на Прим 
1) Започваме построяването на минимално покриващо дърво от произволен връх s: в началото дървото ще бъде T(H,D), H = {s}, D = {}, H - списък съдържащ първият връх, с който започваме и D - празен списък на ребрата. 
2) Повтаряме n–1 пъти:  
    2.1) Избираме реброто (i, j)ϵЕ, такова че: 
        - iϵH, jϵV\H i e връх от множеството H, a j e връх, който не принадлежи на множеството H; 
        - теглото f(i, j) е минимално. 
    2.2) Добавяме върха j към H и реброто (i, j) към D. 
```

## Задача 1. Да се намери минималното покриващо дърво на следният граф. Да използват алгоритмите на Крускал и Прим.
![alt tag](https://github.com/milenaangelova1/DiscreteStructures/blob/master/images/graph2.PNG)




## Алгоритъм на Хъфман за компресия на данни

## Кратка теория
<p align="justify">
Алгоритъмът на Хъфман, разгледан тук е сравнително прост универсален алгоритъм за компресия без загуба на данни (за разлика от алгоритмите със загуба, 
стоящи в основата на MP3, например). При него се предполага, че е даден краен поток от числа в някакъв предварително фиксиран интервал. Ще считаме, 
че става дума за символи, кодирани със ASCII код, т.е. ще разглеждаме информацията като поредица от байтове (числа в интервала 0..255). Алгоритъмът 
се базира на простата идея, че най-често срещаните символи в поредицата трябва да се записват с най-малък брой битове. Така той построява нова азбука, 
която следва тази идея и след това превежда информацията в новата азбука. Кодирането е обратимо, т.е. по кодираната последователност може да се декомпресира - 
да се намери първоначалната поредица.
</p>

### Построяване на дърво на Хъфман
<p align="justify">
Трябва да компресираме даден низ от символи. Искаме да построим двоично дърво, от което ще определим азбука за компресиране.
Алгоритъмът за построяване на дърво се състои от следните стъпки:
1. Създава се честотна таблица на низа - за всеки символ се записва броят на срещанията му.
2. Нека различните символи в низа са n на брой. Създаваме n дървета от по един елемент, където всяко дърво съдържа символ и броя на срещанията му.
3. Намираме двете дървета, които в корените имат най-малко число. Обединяваме дърветата в ново дърво, като в корена записваме сумата от стойностите в двете 
намерени дървета.
</p>

```
Пример:
Нека имаме низа "ABRACADABRA". Честотната таблица за низа е:
Символ:    Брой срещания:
  A               5
  B               2
  C               1
  D               1
  R               2
Строим дървото по следния начин:
```

![alt tag](https://github.com/milenaangelova1/DiscreteStructures/blob/master/images/huffman1.png)

### Построяване на азбуката по дървото на Хъфман
<p align="justify">
  На всеки клон от дървото съпоставяме двоична цифра 0 или 1: 0 за ляв клон, 1 за десен клон. Така на всеки път от корена до някое листо отговаря двоичен низ. Тъй като всяко листо е символ от низа, можем да съпоставим на всеки символ двоичната последователност,която съответства на пътя от корена до листото на символа. Тъй като най-често срещаните символи са най-близко до корена, на тях ще отговарят най-къси последователности. Обратно - на рядко срещаните символи съответстват дълги последователности. <br>
  <b>Пример</b>
  Продължаваме примера отгоре. Дървото, отбелязано с 0 и 1 изглежда така:
</p>

![alt tag](https://github.com/milenaangelova1/DiscreteStructures/blob/master/images/huffman2.png)

```
  Таблицата за кодиране е:
  Символ:   Код:
    A        0
    B       100
    C      1010
    D      1011
    R       11
```
<p align="justify">
След като получим таблицата за кодиране, извършваме кодиране на низа - всеки символ заместваме с неговия код. Така получаваме последователност от 0 и 1. Ако разбием на блокове по 8 бита, можем да получим и изход от байтове. 
</p>

```
Пример
ABRACADABRA → 0 100 11 0 1010 0 1011 0 100 11 0 → 01001101010010110100110 
            → 01001101 01001011 0100110
            → 77 75 38
От 11 символа (байта) = 8*11 бита = 88 бита получихме 23 бита компресирана информация - около 26% 
от оригиналния обем. Получихме четири пъти по-малко описание на "ABRACADABRA".
```

### Декомпресиране на компресирана информация
<p align="justify">
Разкомпресирането на данните става лесно при условие, че имаме дървото на Хъфман. Вървим едновременно по двоичния низ и по дървото, като всеки път като срещнем 0 завиваме наляво, а при 1 - надясно. Когато стигнем до листо, записваме съответния символ и рестартираме от корена. Така стъпка по стъпка получаваме първоначалния низ.
</p>

```
Пример
01001101010010110100110 → 0 100 11 0 1010 0 1011 0 100 11 0 → ABRACADABRA
```
### Задача: Да се напише програма, която чете текст от файл, построява дървото на Хъфман и съхранява двоичната последователност, която кодира оригиналния текст в отделен текстови файл. Използвайте текстовият файл [some_text.txt](https://github.com/milenaangelova1/DiscreteStructures/edit/master/some_text.txt).

За работа с файлове: [тук](https://www.geeksforgeeks.org/g-fact-82)
Алгоритъм на Хъфман [тук](https://github.com/milenaangelova1/DiscreteStructures/edit/master/huffman.c)
Допълнителна литература: [тук](https://github.com/milenaangelova1/DiscreteStructures/blob/master/163405116-c-programming.pdf) и [тук](https://github.com/milenaangelova1/DiscreteStructures/blob/master/274659820-C-Programming-Professional-For-Beginner-s-Zer07.pdf).

# Упражнение 1. Множества. Операции над множества

## 1. Кратка теория
<p align="justify">
Понятията „множество“, „елемент на множество“ и „принадлежност към множество“ понякога се приемат за първични, интуитивно ясни и не се дефинират. Ще перифразираме определението на Г.Кантор - "множество това са много елементи възприемани като едно цяло". Това в пълния смисъл на думата не е логическо определение за понятието множество, а само пояснение, т.к. да се даде определение за нещо означава да се ползват предварително дефинирани понятия - рекурсивна дефиниция.
В математиката с множеството се представя съвкупност от обекти, наричани още елементи, които имат еднакви, определящи множеството качества. Множествата се отбелязват с главни букви от латинската азбука, а принадлежащите им елементи с малки букви. Начинът на подреждане (наредбата) на елементите както и броят на срещанията на определен елемент са без особено значение, т.е. с „{а, b, c }“, „{b, c, a}“ и „{a, a, c, c, c, b, b}“ се означава едно и също множество, чиито елементи са a, b и с. 
Така с означенията „{а, b}“, „{b, a}“ и „{a, b, b}“ се представя едно и също множество, чиито елементи са a и b. С теоретично значение се въвежда понятието празно множество, което представлява множество без елементи. Всяко множество съдържа поне едно подмножество, което е празното множество. Празното множество се съдържа във всяко множество, а универсалното множество, съдържа в себе си всички подмножества от дадения тип елементи.
Едно множество се описва по два начина - с изброяване на неговите елементи или със задаване на условие, което те удовлетворяват.
Две множества са равни тогава и само тогава, когато всеки елемент на едното е елемент и на другото или и двете са празни.
Едно множество се нарича крайно, ако то съдържа n на брой елемента, където n е естествено число (може да бъде и 0). В противен случай, множеството се нарича безкрайно. Пример: за безкрайно множество са естествените числа, реалните числа и др. Едно безкрайно множество се нарича изброимо, когато е равномощно на множеството на естествените числа.
</p>

## 1.1. Операции над множества

### 1.1.1. Обединение

<p align="justify">
Обединение на 2 множества A и B наричаме такова множество C, което се състои от елементите на множеството A или множеството B. Много важно е да не забравяме, че не трябва да оставяме повтарящи се елементи, т.е. ако нещо се среща и в двете множества, го пишем веднъж. Съкратено се записва като

![img](https://latex.codecogs.com/gif.latex?A%20%5Ccup%20B%20%3D%20%5Cleft%20%5C%7B%20x%5Cmid%20x%20%5Cin%20A%20%5Cvee%20x%20%5Cin%20B%20%5Cright%20%5C%7D)
![img](https://www.math10.com/en/university-math/sets/set-union.png)
### 1.1.2. Сечение

<p align="justify">
Сечение на 2 множества A и B наричаме такова множество C, което се състои от елементите принадлежащи едновременно на множеството А и множеството B. Съкратено се записва като</p> 

![img](https://latex.codecogs.com/gif.latex?A%20%5Ccap%20B%20%3D%20%5Cleft%20%5C%7B%20x%5Cmid%20x%20%5Cin%20A%20%5Cwedge%20x%20%5Cin%20B%20%5Cright%20%5C%7D)
![img](https://www.math10.com/en/university-math/sets/set-intersection.png)

### 1.1.3. Разлика

<p align="justify">
Разлика на множеството A с множеството B наричаме такова множество C, което съдържа всички елементи от A, които в същото време не са елементи от B. Съкратено се записва като</p> 

![img](https://latex.codecogs.com/gif.latex?A%20%5Cmid%20B%20%3D%20%5Cleft%20%5C%7B%20x%5Cmid%20x%20%5Cin%20A%20%5Cwedge%20x%20%5Cnotin%20B%20%5Cright%20%5C%7D) и аналогично ![img](https://latex.codecogs.com/gif.latex?B%20%5Cmid%20A%20%3D%20%5Cleft%20%5C%7B%20x%5Cmid%20x%20%5Cin%20B%20%5Cwedge%20x%20%5Cnotin%20A%20%5Cright%20%5C%7D).
![img](https://www.math10.com/en/university-math/sets/difference-of-two-sets.png)

### 1.1.4. Симетрична разлика

<p align="justify">
Симетричната разлика на множеството A с множеството B наричаме такова множество C, което съдържа всички елементи от A, които в същото време не са елементи от B, и едновременно всички елементи от B, които в същото време не се елементи от А. Съкратено се записва като</p> 

![img](https://latex.codecogs.com/gif.latex?A%20%5Cotimes%20B%20%3D%20%5Cleft%20%28%20A%20%5Csetminus%20B%20%5Cright%20%29%20%5Ccup%20%5Cleft%20%28%20B%20%5Csetminus%20A%20%5Cright%20%29)
![img](https://www.math10.com/en/university-math/sets/symmetric-difference.png)

## 2. Задачи

<p align="justify"><b>Задача 1.</b> Да се напише програма, която да реализира операциите обединение, сечение, разлика и симетрична разлика между две множества. Елементите на множествата трябва да се генерират на случаен принцип и да съдържат <b>N</b> на брой различни цели положителни числа принадлежащи на даден интервал. Всяко едно множество трябва да съдържа неповтарящи се елементи. Да се използват библиотечните функция <b>srand</b> и <b>rand</b> за генериране на случайни цели числа - тип <b>int</b>. Използвайте библиотека <b>stdlib.h</b> и <b>time.h</b>. Обърнете внимание на изискването за начална инициализация на <b>srand((unsigned) time(&t));</b>. В противен случай ще се генерират едни и същи числа винаги. Да се принтират новополучените множества.</p>

<p align="justify">а) Да се създаде структура, която да описва множество. Структурата да се казва Set.</p>
<p align="justify">б) Да се създаде функция, която да заделя памет за структурата, като фунцкията има един параметър, който да определя колко елемента ще има множеството. Функцията да връща указател към структурата.</p>

```
Прототип на фунцкията:
Set * set(int number_of_elements);
```

<p align="justify">в) Да се създаде функция, която генерира цели положителни числа в определен интервал и да ги съхранява в масив. За масива да се задели необходимата памет. Функцията да приема един параметър, който да определя колко на брой случайни числа трябва да се генерират. Функцията да връща указател към блока от памет.</p>

```
int * random_generator(int number_of_rand_numbers);
```

<p align="justify">г) Да се създаде функция, която да инициализира множество от цели числа, като използва функцията от предходната задача за генериране на случайни числа. Функцията да връща указател към структурата.</p>

```
void init(Set * set);
```

<p align="justify">д) Да се създаде функция, която да принтира множество от цели числа. Функцията приема един параметър от тип стуктура. Функцията не връща нищо.</p>

```
void print(Set * set);
```

<p align="justify">е) Да се създаде функция, която да намира сечението между две множества. Функцията трябва да примема две множества от тип структура Set. Функцията да връща указател към тип структура Set.</p>

```
Set * intersection(Set * A, Set *B);
```

<p align="justify">ж) Да се създаде функция, която да проверява дали даден елемент се съдържа в дадено множество. Функцията приема като параметри указател към структура Set и търсеният елемент. Функцията трябва да връща 1 ако елемента се съдържа в множеството и 0 в противен случай.</p>

```
unsigned find_element(Set * set, int element);
```

<p align="justify">з) Да се създаде функция, която да намира обединение между две множества. Функцията трябва да примема две множества от тип структура Set. Функцията да връща указател към тип структура Set.</p>

```
Set * Union(Set * A, Set *B);
```

<p align="justify">и) Да се създаде функция, която да намира разлика между две множества. Функцията трябва да примема две множества от тип структура Set. Функцията да връща указател към тип структура Set.</p>

```
Set * difference(Set * A, Set *B);
```

<p align="justify">й) Да се създаде функция, която да намира симетрична разлика между две множества. Функцията трябва да примема две множества от тип структура Set. Функцията да връща указател към тип структура Set.</p>

```
Set * symmetric_difference(Set * A, Set *B);
```

<p align="justify">Забележка:</p>
<p align="justify">Прототипите и структурата да се създадат в отделен файл, който да се казва set.h. Имплементацията на функциите да е в сорс-файл, който да се казва set.c, където трябва да е и main функцията. Хедърният файл set.h трябва да бъде добавен в set.h.</p>

```
// set.c

#include <stdio.h>
...
#include "set.h"

int main() 
{
    return 0;
}
```


<p align="justify"><b>Задача 2.</b> Разширете първа задача, като добавите трето множество и реализирате отново обединение, сечение, разлика и симетрична разлика над три множества, чиито елементи са генерирани на случаен принцип. Да се принтират новополучените множества.</p>

<p align="justify"><b>Задача 3.</b> Реализирайте горните две задачи като вместо цели положителни числа, запълните елементите на масивите с букви на случаен принцип.</p> 

<p align="justify">Може да използвате следното за да генерирате на случаен принцип букви:</p>

```
char randomletter = (char)(rand() % 26 + 65); 
```

# Графи. Алгоритъм на Дейкстра

## Алгоритъм на Дейкстра
<p align="justify">
Най-ефективният метод за намиране на минимални пътища от един конкретен връх до всички останали 
е алгоритъма на Дейкстра.
Нека е даден претеглен ориентиран граф G(V, E) с n върха. За да бъде приложен алгоритъмът, теглата на ребрата f(i,j) 
трябва да бъдат положителни числа. Алгоритъма на Дейкстра няма да работи правилно, ако в графа има ребра с отрицателни тегла. 
Търси се минималният път от фиксиран връх s ∈ V до всички останали върхове на графа. С g(s,i) ще означим дължината на минималния път от s до i. 
Най-общо, алгоритъмът на Дейкстра се основава на следния принцип: За да намерим (s,i), трябва да намерим минималното измежду g(s,j) + f(j,i), за всяко j, j ≠ i. Така, на всеки връх i от графа се присвоява временна стойност d[i], която представлява 
горна граница за g(s, i). В процеса на работа на алгоритъма тази стойност намалява, докато накрая d[i] стане точно равна на g(s,i):
</p>

```
Алгоритъм:
1) Инициализираме масив d[] по следния начин:  
d[i] = A[s][i] за всеки съсед i ∈ V на s.  
d[i] = MAX_VALUE, за всеки връх i, несъседен на s.  
След приключване на алгоритъма d[i] == MAX_VALUE т.с.т.к. между s и i няма път. 
2) Въвеждаме множество Т, което в началото съдържа всички върхове на графа, без s: 
T = V\{s} 
3) Докато T съдържа поне един връх i, за който d[i] < MAX_VALUE: 
3.1) Избираме връх j∈Т такъв, че d[j] да бъде минимално. 
3.2) Изключваме j от T: T = T\{j} 
3.3) За всяко i∈T изпълняваме d[i] = min(d[i], d[j] + A[j][i]); 
```

## Задача 1: Да се реализира алгоритъма на Дейкстра върху следният граф. Да се намерят всички минимални пътища от връх 0 до всички останали върхове.

![alt tag](https://github.com/milenaangelova1/DiscreteStructures/blob/master/Lab%204%20Graphs/images/graph1.PNG)

Примерен изход от програмата, като това са разстоянията от връх 1 до връх 2 и 3: 
```
Минимален път от връх 1 до 2:  1 2, дължина на пътя: 23 
Минимален път от връх 1 до 3:  1 2 4 3, дължина на пътя: 32 
...

```

## Задача 2: Да се намери минималното скелетно дърво на графа от първа задача. Избор на алгоритъм: Крускал или Прим.

## Алгоритъм на Прим
```
Алтернатива нa алгоритъма на Крускал за намиране на минимално покриващо дърво е алгоритъмът на Прим.  
Алгоритъм на Прим 
1) Започваме построяването на минимално покриващо дърво от произволен връх s: в началото дървото 
ще бъде T(H,D), H = {s}, D = {}, H - списък съдържащ първият връх, с който започваме и 
D - празен списък на ребрата. 
2) Повтаряме n–1 пъти:  
    2.1) Избираме реброто (i, j)ϵЕ, такова че: 
        - iϵH, jϵV\H i e връх от множеството H, a j e връх, който не принадлежи на множеството H; 
        - теглото f(i, j) е минимално. 
    2.2) Добавяме върха j към H и реброто (i, j) към D. 
```

## Алгоритъм на Крускал
```
    Разглеждаме претеглен неориентиран граф G(V, E).  
    Алгоритъм на Крускал за намиране на минимално покриващо дърво. 
    1) Създаваме n множества, като в i-тото множество поставяме i-тия връх от графа. 
    2) Сортираме ребрата на графа във възходящ ред (по теглата им). 
    3) Създаваме празно дърво T(V,{}). След приключване на алгоритъма T ще бъде търсеното покриващо дърво.  
    4) Последователно (n–1 пъти) добавяме ребро (i,j)ϵЕ към T, така че да бъде изпълнено: 
        - теглото f(i, j) да бъде възможно най-малко (разполагаме със сортиран по теглата списък на 
        ребрата от графа) 
        - върховете i и j да се намират в различни множества 
        След всяко добавено ребро (i,j) обединяваме множествата, в които се намират i и j.  
```

Линк: https://www.codepile.net/pile/0kxj3RLj
